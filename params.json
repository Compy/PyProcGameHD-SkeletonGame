{"name":"PyProcGameHD+SkeletonGame","tagline":"The current HD VGA Fork of PyProcGame (w/ HW Accel) + SkeletonGame to accelerate new game development","body":"The code, documentation, and this page itself are a work in progress.  Please bear with me.  Please report bugs, issues, problems, etc.  Either use the GitHub issue tracker, or go to the thread on the PinballControllers forum, [here](http://www.pinballcontrollers.com/forum/index.php?topic=1500.0).  \r\n\r\nThank you.  \r\n- Michael\r\n\r\n#  PyProcGame-HD + SkeletonGame\r\n## Contents: ##\r\n\r\n* [Overview](#overview)\r\n* [Installation](#installation)\r\n* [SkeletonGame](#skeletongame-big-picture)\r\n* [Event Flow, theory, etc.](#game-event-flow)\r\n* [Getting Started with SkeletonGame](#getting-started)\r\n* [Change Log](#change-log)\r\n\r\n# Overview\r\n\r\n## PyProcGame-HD\r\nThis is a fork of PyProcGame, meant to replace PyProcGame for users who wish to create LCD-based PyProcGame games that are powered by a P-ROC.\r\n\r\nTraditional DMD support has been broken, in favor of supporting traditional PC display hardware (i.e., LCD display). Specifically this version enables full-color frames (with alpha and per-pixel alpha transparency) running resolutions far in excess of 128x32.  Hardware requirements moderate if hardware acceleration is available.\r\n\r\nThis release replaces the previous HD VGA fork of PyProcGame and it's functionality is a superset of that version.  This release has been re-written (and aggressively optimized) to leverage SDL2+PySDL2 graphics hardware acceleration features.  Many things are now possible with nominal overhead, including 'dot-filter', alpha transparency, per-pixel alpha, just to name a few.  The prior PyGame-based version remains for those who might need it for some reason or another.\r\n\r\nNote: This version does not support the PyGame or Pyglet based desktop as the original PyProcGame does.  There are several ways to use PyProcGameHD for some games and have it live side-by-side with PyProcGame (traditional DMD) games.  The easiest way is to just include PyProcGameHD's procgame folder as a subfolder of your game.\r\n\r\nA Display Architecture Tutorial for both PyProcGameHD specifics and PyProcGame, in general, is provided [here](http://mjocean.github.io/PyProcGameHD-SkeletonGame/DMD_Tutorial.html).\r\n\r\n\r\n## SkeletonGame\r\n\r\nSkeletonGame is a collection of classes to speed up new game development, and is also included (and maintained) as part of this release.  If you are a new P-ROC developer, you should strongly consider using it.  If you have an existing codebase, you can migrate to this latest version of the HD Framework without using SkeletonGame, with minimal code changes.\r\n\r\nSkeletonGame is meant to be a proper third tier on top of BasicGame; think of it as the logical continuation of Starter.py --that is, if starter were a class that people were expected to subclass.  SkeletonGame is just a bunch of additions to pyprocgame (many of which lifted from the JD sample game). It leverages everything that those of use who use PyProcGame know and love, and only intends to streamline some things for new users. It should help you make games faster.  Think of it as sucking out the best parts of the Judge Dredd sample game, modifying it to be generic, adding stuff to make developing games easier, and having the whole thing running on the latest HD VGA fork of PyProcGame. \r\n\r\nIf SkeletonGame works, it means you (as the programmer) should:\r\n\r\n- have VERY few lines of code in your game class.\r\n- spend most of your time coding the logic for *modes*.\r\n- be able to leverage fairly standard modes that have been written before.\r\n- use helpers to create DMD content (in code) much easier.\r\n- get started quickly.\r\n\r\nA Sample game that has been provided, [here](https://github.com/mjocean/PyProcGameHD-SkeletonGame/tree/master/SampleGame)\r\n\r\n## pyprocgame\r\n\r\nThis work is built on top of (and would be nothing without) pyprocgame, which is a high-level pinball development framework for use with P-ROC (Pinball Remote Operations Controller).  Pyprocgame was written by Adam Preble and Gerry Stellenberg.  More information about P-ROC is available at [pinballcontrollers.com](http://pinballcontrollers.com/).  See the [pyprocgame site](http://pyprocgame.pindev.org/) for the full pyprocgame documentation.\r\n\r\n# Installation\r\n\r\n## Prerequisites\r\n\r\npyprocgame requires the following libraries.  Before installing any of these, follow the installation guide, below.\r\n\r\n- [Python 2.6](http://python.org/)\r\n- [pypinproc](http://github.com/preble/pypinproc) -- native Python extension enabling P-ROC hardware access and native DMD frame manipulation.\r\n- [setuptools](http://pypi.python.org/pypi/setuptools) -- required for procgame script installation.  Also adds easy\\_install, a helpful installer tool for popular Python modules.\r\n- [pyyaml](http://pyyaml.org/) -- YAML parsing.\r\n- One of the Python graphics and sound modules:\r\n  - [pygame](http://www.pygame.org/)\r\n- [Python Imaging Library](http://www.pythonware.com/products/pil/) (PIL)\r\n\r\nAdditionally, this version requires:\r\n- [SDL2 32bit (only use 64 if you are using the 64bit Python --you probably aren't).](https://www.libsdl.org/download-2.0.php\r\n- [SDL2 TTF (Font support, also 32bit)](http://www.libsdl.org/projects/SDL_ttf/)\r\n- [PySDL2 32-bit (x86)](http://pysdl2.readthedocs.org/en/latest/install.html)\r\n- [PyOSC 0.3.5b-5294.zip](https://pypi.python.org/pypi/pyOSC)\r\n- *Optional:* For MP4 support install OpenCV and libffmpeg\r\n\r\n## Installation Guide\r\n\r\n1.  Run a [\"OneClickInstall\"](http://proctools.catster.net/) from Jimmy (note, there is no one-click installer for OSX at this time)\r\n  *test that it worked* --from a command-prompt run ``python`` and run the following instructions:  \r\n\r\n```python\r\nimport pinproc\r\nimport procgame\r\nimport pygame\r\nprint pinproc.EventTypeBurstSwitchOpen\r\n```\r\n\r\nThe first three lines should return the prompt with no feedback.  The last should print ``6``.  This is how you know it worked.\r\n*TODO: post debugging instructions.*\r\n\r\n2. Install the SkeletonGame/HD VGA SDL2 dependencies.  \r\n\t2. Download and install [PySDL2 for your platform]\r\n\t(http://pysdl2.readthedocs.org/en/latest/install.html)\r\n\t1. Install the 32-bit (x86) versions of the SDL2 and the SDL2_TTF libraries -- \r\n\tFor windows, put them in a directory called ``C:\\Python26\\DLLs\\sdl2``.  \r\n  \t- [sdl2](https://www.libsdl.org/download-2.0.php)\r\n  \t- [sdl2_ttf](http://www.libsdl.org/projects/SDL_ttf/)\r\n\t1.  Download and install [pyOSC-0.3.5b-5294.zip](https://pypi.python.org/pypi/pyOSC)\r\n\t1.  Either set the PYSDL2_DLL_PATH (as per the instructions, [here](http://pysdl2.readthedocs.org/en/latest/integration.html) or add a ``PYSDL2_DLL_PATH`` in the game's ``config.yaml``.\r\n\t1. *Optional:* For MP4 support install OpenCV and libffmpeg\r\n\r\n3. Install the SkeletonGame version of PyProcGame along-side the One-Click installed pyprocgame.  Download the ZIP of the files here, and extract it to somewhere other than your existing pyprocgame-master folder (e.g., C:\\P-ROC\\pyprocgame-hd\\).  Within that directory, from the command line run:\r\n\r\n```python setup.py develop```\r\n\r\nThis will install SkeletonGame in 'develop' mode, such that when you import pyprocgame from any python script, it will use this version, from the current location.\r\n\r\n\timport procgame.game\r\n\r\nIt will also update the \"procgame\" command line tool into a system-dependent location.  The updated version works with the color file formats.  On Linux and Mac OS X systems this will probably be in your path such that you can type, from the command line:\r\n\r\n\tprocgame\r\n\r\nand see a list of available commands.  If it is not in your path you can invoke it directly, or modify your PATH environment variable.  Note that on Windows the procgame script is typically located in C:\\Python26\\Scripts.\r\n\r\n### *Optional:* the graphical switch tester: ###\r\n1. Download/install wxPython (for windows, this is wxPython3.0-win32-3.0.2.0-py26.exe)\r\nhttp://www.wxpython.org/download.php \r\n2. Download the switchMatrixClient.py and put it in the main game folder.  \r\nhttps://github.com/mjocean/OscSwitchMatrixGUI\r\n3. Running the switch matrix client is as follows:\r\n\r\n```\r\npython switchMatrixClient.py -y config/t2.yaml -p 9000 -i t2_SM.jpg -l t2.layout\r\n```\r\n\r\nwhere:\r\n  * `` config/t2.yaml`` is the path to the machine configuration file\r\n  * ``t2_SM.jpg`` is a playfield image shrunk to fit the screen.\r\n  * ``t2.layout`` is a layout file saved from this tool (the first run will not include this ``-l t2.layout`` argument)\r\n\r\n\r\n# SkeletonGame: Big Picture\r\n## Overview\r\n\r\nModule       | Layer\r\n-------------------|----\r\nSkeletonGame       | (L3)\r\nBasicGame          | (L2)\r\nlibpinproc/pinproc | (L1)\r\n\r\n\r\nMotivation: Most people who learn PyProcGame programming have done so by looking at existing open-source games and there are many good ones to learn from.  Unfortunately, the copy/paste/merge process is fairly error prone. I've done it a few times now and it gets dangerous with sequence dependant, asynchronous (i.e., event-driven) code that spans multiple files. Suppose 'project A' assumes that the attract mode will call `start_ball()`, but 'project B' assumes that `start_ball()` is called by the trough handler --depending on what you grab and from where, you may wind up with no balls in the trough or two balls.  Worse I've seen and encountered plenty of instances of the game appearing to be hung or crashing because some event doesn't occur due to functions being called in the wrong order as a result of copy/paste/merge-fail. Having worked on a few P-ROC projects now, I've tried to distill the common bits from each of those games so that I can avoid rewriting the same lines again and again.\r\n\r\n## SkeletonGame includes: \r\n\r\n- the class ``SkeletonGame`` (which is a subclass of `BasicGame`).  This class will serve as the new superclass for your game. This class includes the following (by default):\r\n    - tracking ball counts, ball time, game counts, game time, loads/saves settings and data\r\n    - assetManager (all your images, sounds, music, fonts, lampshows are pre-loaded by defining a yaml file)\r\n    - a better `Player` class: supports player state tracking built in with appropriate methods for access. \r\n    - `soundController` mode auto created and loaded \r\n    - OSC mode auto loaded (though apparently based on an old version..oops)\r\n    - Built-in (already working) trough, ballsave, ballsearch, and tilt/slam tilt modes (all based on Gerry/Adam's versions)\r\n    -  ... a VERY simple attract mode that's based on a simple, yet powerful yaml file/format\r\n    -  ... service mode (basically Adam's) that senses dmd size\r\n    -  ... high score entry (based on Adam's but in color) that senses dmd size\r\n    -  ... high score frame generation for display in attract mode\r\n    -  ... score display essentially based on Adam's but updated to use color fonts, background animations, etc. \r\n    -  ... bonus helper (just like score: `bonus(tag, quantity)`) and a built-in bonus tally mode that kicks in at the end of the ball and shows any bonuses awarded to the player during their ball\r\n- `dmdHelper` \"mode\" that generates a message on screen shown over a single image/animation, or a stack of them. It makes using the DMD extremely painless.  It's usage is: ```displayText(text, key)``` \r\nIf key is a list, it builds a grouped layer for all the keys. If text is a list instead of single string, all the text is shown on the frame. A single line is centered vertically, two lines are shown at 1/3, and 2/3, three lines at 1/4,2/4, and 3/4... You get the idea. \r\n- Automatic state progressions without having to code for it in your game.  No more calls to `start_ball()`, `end_ball()`, etc.  \r\n- A new optional-Mode superclass called `AdvancedMode`;  AdvancedMode offers:\r\n    - a \"lifecycle type\" (ball, game, system, or custom) --modes are auto added/removed based on that type. They only need to be created by importing them in the game code and creating them in init. Skeleton game adds/removed them as per their type \r\n    - a refined set of game progress events that get sent to AdvancedModes, in priority order, prior to the actual event occuring. Now modes themselves can respond directly to `evt_game_starting`, `evt_ball_starting`, `evt_ball_ending`, `evt_game_ending`, `evt_player_added`, `evt_tilt`, and `evt_tilt_ball_ending` events. Modes can also request to postpone the event propagation (i.e., the calling of the next event handler) by returning a number of seconds that the mode needs to 'finish up' (e.g., play a special animation or sound) or can delay and stop further propegation by returning a tuple of the delay in seconds and the second entry is `True`\r\n- A small and hopefully well commented example game based on T2.\r\n\r\n### Coming Soon: ###\r\n\r\n- automatic handling of AC Relay coils (from yaml markup, only)\r\n- match mode\r\n- more features to the bonus mode: using a yaml file to define about valid bonuses, score per award, Max numbers to allow of said award, etc. the tally is still in progress --this is not totally done.\r\n\r\n## Game event flow\r\n(changes from PyProcGame, etc.)\r\n\r\nA game class that is subclassed from SkeletonGame should be very short.  The example provided is fewer than 60 lines if you exclude imports, comments and whitespace.  Most of your code should be present in your mode classes, instead.\r\n\r\nYour game class should not call game_start, ball_end, etc.  It should also not need to subclass these methods.  You can, of course, do so, but you should not HAVE to.  SkeletonGame (and its constiutent parts, including the attract and bonus modes) will handle the successive event progression.  In a typical game, this looks like:\r\n\r\n### Your game class iniializes itself in main()... ###\r\n Behind the scenes, super(SkeletonGame,self).__init__ does the following:\r\n\r\n- initializes the sound controller\r\n- finds the DMD settings from the config.yaml and sets up your display\r\n- creates a lampshow controller\r\n- loads all your assets from the asset_list.yaml file (shows the player a graphical loading bar)\r\n- initializes and connects the ball_save and trough modes\r\n- loads the OSC mode, bonus mode, score display \r\n\r\nThen, any AdvancedMode derived modes that you initialize are automatically added to skeletonGame's 'known modes' so it can add/remove them for you, based on their mode_type (game, ball, system, custom).  \r\n\r\n### When you call reset(): ###\r\n\r\nThe SkeletonGame version of reset() protects the modes that need to be in the game.  The old reset method would remove ALL modes from the game, but reset() in skeletonGame's will re-add modes that should not be removed and protect certain modes (e.g., the OSC controller) from being removed at all.\r\n\r\nThe last thing your reset() method should do is call: self.start_attract_mode()\r\n\r\nThen, SkeletonGame takes over again, initiating the attract mode from the yaml file.\r\nWhen the player presses the switch with the name 'startButton', SkeletonGame will automatically:\r\n\r\n- find modes with method *evt_game_starting* and call them \r\n- find modes with method *evt_player_added* and call them\r\n- find modes with method *evt_ball_starting* and call them \r\n- add a ball to the shooter lane.\r\n\r\nYour modes hopefully do something here :)\r\n\r\nWhen the ball drains and the trough is full, SkeletonGame will automatically:\r\n\r\n- finds modes with method *evt_ball_ending* and calls them\r\n- show the 'end of ball' and bonus sequence (if bonuses were awarded)\r\n- if the balls number is *less than* the quantity specified in the machine yaml\r\n    * find modes with method *evt_ball_starting* and call them (repeating the cycle)\r\n- if the ball number is *greater than* the quantity specified in the machine yaml\r\n    * finds modes with method *evt_game_ending* and calls them\r\n    * checks the players score against the high scores.  If greater, the player may enter his/her scores\r\n    * attract mode is shown again\r\n\r\nSo, the available events are:\r\n\r\nEvent | when fired:\r\n------|--------------\r\n``evt_player_added(player)`` | fired when a player is added; may be player 1, 2\r\n``evt_game_starting`` | fired before the game starts.  This is your chance to do something prior to game start\r\n``evt_ball_starting`` | fired before the ball is kicked into the shooter lane\r\n``evt_ball_ending(shoot_again, last_ball)`` | fired as the ball is ending (i.e., the trough is full).  shoot_again will be true if the player has an extra ball lined up to follow this one; last_ball indicates that this is the last ball prior to this player's game ending\r\n``evt_game_ending`` | the player's game is about to end.\r\n``evt_tilt`` | the player has tilted the machine (exceeded all warnings on the plumb bob)\r\n``evt_tilt_ball_ending`` | all balls are accounted for following the player tilting the machine (exceeded all warnings on the plumb bob)\r\n\r\n\r\n\r\n# Making your first SkeletonGame-based game:\r\n## Getting Started \r\n\r\n0. Get everything installed and working as per the installation guide, above.\r\n\r\n1. Create your project workspace (folder structure):\r\n\r\n    Assuming I put my game in a folder called ``MyGame`` my directory structure should look like:\r\n\r\n        MyGame/\r\n        |\r\n        +--config/      [this is where most yaml files live]\r\n        |\r\n        +--assets/      [your asset_list.yaml is here as well as individual dmds, sounds, lampshows]\r\n        |\r\n        +--my_modes/    [.py files for the modes that you add to your game]\r\n        |\r\n        +--MyGame.py    [your game class]\r\n        |\r\n        +--config.yaml  [these are the settings for your game: dmd size, resolution, etc.]\r\n\r\n    Before we can really begin, you need a ``config.yaml`` file and a machine yaml file.\r\n\r\n2. ``config.yaml``\r\n\r\n    Use the default provided.  TODO: Paste documetnation from pinballcontrollers forum\r\n\r\n3. ``machine.yaml``\r\n\r\n    This is the machine definition file.  It defines all the switches, lamps and coils in your machine.  Some samples are available.\r\n\r\n    You **must** adhere to a few naming conventions:\r\n        \r\n      - your trough switches should be named ``trough1``, ``trough2``, .. ``troughN`` where N==num trough switches.\r\n      - your start button should be called ``startButton``\r\n      - your shooter lane switch should be called ``shooter``\r\n      - your (bob) tilt switch should be called ``tilt``\r\n      - your slam-tilt switch should be called ``slamTilt`` \r\n      - ball search is handled differently!  switches and coils should be tagged for ball search, as shown in the example.\r\n\r\n4. Build your ``asset_list.yaml``\r\n\r\n    TODO: quite a lot to write about the format.  The example is probably good to reporoduce here.  \r\n\r\n    You must be sure you define a few things:\r\n\r\n      - A Font or HDFont named: `tilt-font-big`, `tilt-font-small`, `settings-font-small`, `high_score_entry_inits`, `high_score_entry_msg` `high_score_entry_letters`\r\n      - blah blah\r\n      - something else that's vital...\r\n\r\n5. Other important yaml files:\r\n\r\n    ###score_display.yaml###\r\n\r\n```yaml\r\n    ScoreLayout:\r\n      Fonts:\r\n            bottom_info:                  # the bottom info Credits/Ball Num\r\n                  Font: score_sub         # value corresponds to a font key in asset_list.yaml\r\n                  FontStyle: blueish      # FontStyles are also in asset_list and OPTIONAL\r\n            single_player:                # Fonts/Styles for single player play\r\n                  10_digits:\r\n                        Font: score_activeL # corresponds to keys in asset_list.yaml\r\n                  11_digits:\r\n                        Font: score_activeM\r\n                  12plus:\r\n                        Font: score_activeS\r\n            multiplayer:                 # Fonts/Styles for multiplayer play\r\n                  active:                 # style for the active player\r\n                        7_digits: \r\n                              Font: score_activeL\r\n                        8_digits: \r\n                              Font: score_activeM\r\n                        9plus: \r\n                              Font: score_activeS\r\n                  inactive:               # style for the inactive player(s)\r\n                        7_digits: \r\n                              Font: score_inactive\r\n                        8_digits: \r\n                              Font: score_inactive\r\n                        9plus: \r\n                              Font: score_inactive\r\n\r\n```\r\n\r\n###attract.yaml###\r\n```yaml\r\n        Sequence:\r\n        - Combo:\r\n            Text:\r\n                - \"MOcean\"\r\n                - \"\"\r\n                - \"Presents\"\r\n            Font: large\r\n            lampshow: attract_show_1\r\n            duration: 2.0\r\n        - Animation:\r\n            Name: t800-war\r\n        - Combo:\r\n            Text:\r\n                - \"Terminator\"\r\n                - \"\"\r\n                - \"2.0\"\r\n            Font: large\r\n            Animation: chrome\r\n            FontStyle: blueish\r\n            lampshow: attract_show_2\r\n            duration: 2.0\r\n        - HighScores:\r\n            Font: large\r\n            Background: chrome\r\n            Order:\r\n                - player\r\n                - category\r\n                - score\r\n            duration: 1.0\r\n```\r\n\r\n### Steps to making your game: ###\r\n\r\n## 1. Look at the Sample game that has been provided, [here](https://github.com/mjocean/PyProcGameHD-SkeletonGame/tree/master/SampleGame)\r\n\r\n## 2. Look at the Display Architecture Tutorial, [here](http://mjocean.github.io/PyProcGameHD-SkeletonGame/DMD_Tutorial.html)\r\n\r\nTODO: This...\r\n\r\n# PyProcGame Documentation\r\n\r\nPlease see the [pyprocgame Documentation](http://pyprocgame.pindev.org/) site for the pyprocgame Manual and detailed API documentation.\r\n\r\n\r\n## License\r\n\r\nNew components are Copyright (c) 2014-2015 Michael Ocean and Josh Kugler\r\nContent unchanged from PyProcGame remain Copyright (c) 2009-2011 Adam Preble and Gerry Stellenberg\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}